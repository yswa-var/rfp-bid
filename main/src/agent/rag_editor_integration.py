"""
RAG Editor Integration Module for Proposal Supervisor

Integrates the AI Dynamic Editor with RAG capabilities into the proposal generation flow.
Allows team outputs to be used for updating DOCX documents with RAG-enhanced content.
"""

import os
import sys
import subprocess
import json
import time
from pathlib import Path
from typing import Dict, Any, List, Optional
from openai import OpenAI
from dotenv import load_dotenv

# Add the MCP client path for RAG editor integration
script_dir = os.path.dirname(os.path.abspath(__file__))
mcp_client_path = os.path.join(os.path.dirname(os.path.dirname(script_dir)), 'Mcp_client_word')

if os.path.exists(mcp_client_path):
    sys.path.insert(0, mcp_client_path)
    print(f"✅ Added MCP client path: {mcp_client_path}")
else:
    print(f"❌ MCP client path not found: {mcp_client_path}")

load_dotenv()

class RAGEditorIntegration:
    """Integration class for RAG Editor with Proposal Supervisor"""
    
    def __init__(self):
        self.client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
        self.server_process = None
        self.tools = []
        self.rag_coordinator = None
        self.document_path = None
        
        # Initialize RAG Coordinator
        try:
            from .proposal_rag_coordinator import ProposalRAGCoordinator
            self.rag_coordinator = ProposalRAGCoordinator()
            print("✅ RAG Coordinator initialized for editor integration")
        except Exception as e:
            print(f"❌ Failed to initialize RAG Coordinator: {e}")
    
    def setup_document(self, document_name: str = "main/test_output/proposal_20250927_142039.docx") -> bool:
        """Setup the DOCX document for editing"""
        try:
            # Create document path - use the specified path
            if document_name.startswith("main/"):
                # Use the main directory as base
                main_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
                self.document_path = os.path.join(main_dir, document_name)
            else:
                # Fallback to mcp_client_path for backward compatibility
                self.document_path = os.path.join(mcp_client_path, document_name)
            
            # Ensure the directory exists
            os.makedirs(os.path.dirname(self.document_path), exist_ok=True)
            
            # Check if document exists, create if not
            if not os.path.exists(self.document_path):
                self._create_template_document()
            
            print(f"📄 Document setup: {self.document_path}")
            return True
            
        except Exception as e:
            print(f"❌ Document setup failed: {e}")
            return False
    
    def _create_template_document(self):
        """Create a template DOCX document for proposal generation"""
        try:
            from docx import Document
            from docx.shared import Inches, Pt
            from docx.enum.text import WD_ALIGN_PARAGRAPH
            
            doc = Document()
            
            # Add title
            title = doc.add_heading('RFP Proposal Response', 0)
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER
            
            # Add sections placeholders
            sections = [
                "1. Executive Summary",
                "2. About CPX",
                "3. Understanding of Requirements", 
                "4. Proposed Solution",
                "5. Implementation Plan",
                "6. Team and Experience",
                "7. Pricing",
                "8. Terms and Conditions",
                "9. Additional Services",
                "10. Appendices"
            ]
            
            for section in sections:
                doc.add_heading(section, level=1)
                doc.add_paragraph(f"[{section} content will be generated by specialized teams]")
                doc.add_paragraph()  # Add spacing
            
            # Save document
            doc.save(self.document_path)
            print(f"📄 Template document created: {self.document_path}")
            
        except Exception as e:
            print(f"❌ Template creation failed: {e}")
    
    def start_mcp_server(self) -> bool:
        """Start the MCP server for Word document editing"""
        try:
            server_script = os.path.join(mcp_client_path, "Office-Word-MCP-Server", "word_mcp_server.py")
            
            if not os.path.exists(server_script):
                print(f"❌ MCP server script not found: {server_script}")
                return False
            
            # Start server in background
            self.server_process = subprocess.Popen(
                [sys.executable, server_script],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=os.path.dirname(server_script)
            )
            
            # Wait a moment for server to start
            time.sleep(2)
            
            # Check if server is running
            if self.server_process.poll() is None:
                print("✅ MCP server started successfully")
                return True
            else:
                print("❌ MCP server failed to start")
                return False
                
        except Exception as e:
            print(f"❌ Failed to start MCP server: {e}")
            return False
    
    def query_rag_for_context(self, query_text: str, context_type: str = "proposal") -> Dict[str, List]:
        """Query RAG systems for relevant context"""
        try:
            if not self.rag_coordinator:
                return {"template_context": [], "examples_context": [], "session_context": []}
            
            # Query all RAG databases
            contexts = self.rag_coordinator.query_all_rags(query_text, k=3)
            
            return {
                "template_context": contexts.get('template_context', []),
                "examples_context": contexts.get('examples_context', []),
                "session_context": contexts.get('session_context', [])
            }
            
        except Exception as e:
            print(f"❌ RAG query failed: {e}")
            return {"template_context": [], "examples_context": [], "session_context": []}
    
    def generate_enhanced_content(self, team_output: str, section_name: str, rfp_context: str = "") -> str:
        """Generate enhanced content using RAG context and team output"""
        try:
            # Query RAG for relevant context
            rag_contexts = self.query_rag_for_context(f"{section_name} {team_output[:200]}", "proposal")
            
            # Format contexts
            template_context = self._format_context_section(rag_contexts.get('template_context', []))
            examples_context = self._format_context_section(rag_contexts.get('examples_context', []))
            session_context = self._format_context_section(rag_contexts.get('session_context', []))
            
            # Build comprehensive prompt
            prompt = f"""Enhance and refine the following team output for a professional RFP proposal section:

**Section:** {section_name}
**Team Output:** {team_output}
**RFP Context:** {rfp_context[:300]}

**RAG KNOWLEDGE BASE CONTEXT:**

**Template Context (Structure/Format):**
{template_context}

**Examples Context (Previous Similar Content):**
{examples_context}

**Session Context (Current RFP/Project):**
{session_context}

**INSTRUCTIONS:**
- Enhance the team output with professional proposal language
- Use template context for proper structure and format
- Incorporate relevant examples and best practices
- Align with current RFP requirements
- Make content specific, actionable, and compelling
- Format as clean text ready for DOCX insertion
- DO NOT include formatting artifacts or line numbers
- Ensure content flows naturally and professionally

**ENHANCED CONTENT:**"""
            
            response = self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.3,
                max_tokens=2000
            )
            
            enhanced_content = response.choices[0].message.content.strip()
            print(f"✅ Enhanced content generated for {section_name}")
            return enhanced_content
            
        except Exception as e:
            print(f"❌ Content enhancement failed: {e}")
            return team_output  # Return original if enhancement fails
    
    def _format_context_section(self, contexts: List) -> str:
        """Format RAG context section for AI processing"""
        if not contexts:
            return "No relevant context found."
        
        formatted = []
        for i, context in enumerate(contexts[:3], 1):  # Limit to top 3
            content = context.get('content', str(context))[:300]  # Truncate long content
            formatted.append(f"{i}. {content}")
        
        return "\n".join(formatted)
    
    def update_document_section(self, section_name: str, content: str) -> bool:
        """Update a specific section in the DOCX document"""
        try:
            if not self.document_path or not os.path.exists(self.document_path):
                print("❌ Document path not set or file doesn't exist")
                return False
            
            # Use MCP tools to update document
            # This would integrate with the Word MCP server
            print(f"📝 Updating document section: {section_name}")
            
            # For now, we'll use a simple approach
            # In a full implementation, this would use the MCP Word tools
            
            return True
            
        except Exception as e:
            print(f"❌ Document update failed: {e}")
            return False
    
    def process_team_outputs(self, team_responses: Dict[str, Any], rfp_content: str = "") -> Dict[str, str]:
        """Process all team outputs and enhance them for document integration"""
        try:
            enhanced_outputs = {}
            
            # Team to section mapping
            team_sections = {
                "technical_team": "Proposed Solution",
                "finance_team": "Pricing", 
                "legal_team": "Terms and Conditions",
                "qa_team": "Quality Assurance"
            }
            
            for team_name, response in team_responses.items():
                if team_name in team_sections:
                    section_name = team_sections[team_name]
                    team_content = response.get('content', '')
                    
                    # Enhance content with RAG
                    enhanced_content = self.generate_enhanced_content(
                        team_content, 
                        section_name, 
                        rfp_content
                    )
                    
                    enhanced_outputs[team_name] = {
                        "section": section_name,
                        "original": team_content,
                        "enhanced": enhanced_content,
                        "timestamp": response.get('timestamp', '')
                    }
                    
                    print(f"✅ Processed {team_name} output for {section_name}")
            
            return enhanced_outputs
            
        except Exception as e:
            print(f"❌ Team output processing failed: {e}")
            return {}
    
    def generate_final_document(self, enhanced_outputs: Dict[str, Any], output_path: str) -> bool:
        """Generate final DOCX document with all enhanced team outputs"""
        try:
            from docx import Document
            from docx.shared import Inches, Pt
            from docx.enum.text import WD_ALIGN_PARAGRAPH
            
            doc = Document()
            
            # Add title
            title = doc.add_heading('RFP Proposal Response', 0)
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER
            
            # Add sections in order
            section_order = [
                ("technical_team", "4. Proposed Solution"),
                ("finance_team", "7. Pricing"),
                ("legal_team", "8. Terms and Conditions"), 
                ("qa_team", "Quality Assurance")
            ]
            
            for team_name, section_title in section_order:
                if team_name in enhanced_outputs:
                    doc.add_heading(section_title, level=1)
                    
                    enhanced_content = enhanced_outputs[team_name]['enhanced']
                    
                    # Split content into paragraphs
                    paragraphs = enhanced_content.split('\n\n')
                    for para in paragraphs:
                        if para.strip():
                            doc.add_paragraph(para.strip())
                    
                    doc.add_paragraph()  # Add spacing
            
            # Save document
            doc.save(output_path)
            print(f"📄 Final document saved to {output_path}")
            return True
            
        except Exception as e:
            print(f"❌ Final document generation failed: {e}")
            return False
    
    def cleanup(self):
        """Cleanup resources"""
        try:
            if self.server_process:
                self.server_process.terminate()
                self.server_process.wait()
                print("🛑 MCP server stopped")
        except Exception as e:
            print(f"⚠️ Cleanup error: {e}")


def integrate_rag_editor_with_proposal(team_responses: Dict[str, Any], rfp_content: str = "", output_dir: str = "responses", document_name: str = "main/test_output/proposal_20250927_142039.docx") -> Dict[str, str]:
    """
    Main integration function to process team outputs with RAG editor
    
    Args:
        team_responses: Dictionary of team responses from proposal supervisor
        rfp_content: Original RFP content for context
        output_dir: Directory to save enhanced outputs
        document_name: Path to the DOCX document to update (default: main/test_output/proposal_20250927_142039.docx)
    
    Returns:
        Dictionary with file paths of generated documents
    """
    try:
        print("🚀 Starting RAG Editor integration with proposal outputs...")
        
        # Initialize RAG editor integration
        rag_editor = RAGEditorIntegration()
        
        # Setup document
        if not rag_editor.setup_document(document_name):
            print("❌ Failed to setup document")
            return {}
        
        # Start MCP server
        if not rag_editor.start_mcp_server():
            print("❌ Failed to start MCP server")
            return {}
        
        # Process team outputs
        enhanced_outputs = rag_editor.process_team_outputs(team_responses, rfp_content)
        
        if not enhanced_outputs:
            print("❌ No enhanced outputs generated")
            return {}
        
        # Create output directory
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)
        
        # Generate final document
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        final_docx = output_path / f"rag_enhanced_proposal_{timestamp}.docx"
        
        success = rag_editor.generate_final_document(enhanced_outputs, str(final_docx))
        
        # Save enhanced outputs as JSON
        enhanced_json = output_path / f"enhanced_outputs_{timestamp}.json"
        with open(enhanced_json, 'w', encoding='utf-8') as f:
            json.dump(enhanced_outputs, f, indent=2, ensure_ascii=False)
        
        # Cleanup
        rag_editor.cleanup()
        
        results = {
            "enhanced_json": str(enhanced_json),
            "enhanced_outputs": enhanced_outputs
        }
        
        if success:
            results["final_docx"] = str(final_docx)
        
        print("✅ RAG Editor integration completed successfully")
        return results
        
    except Exception as e:
        print(f"❌ RAG Editor integration failed: {e}")
        return {}
